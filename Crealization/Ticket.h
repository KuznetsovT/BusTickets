#pragma once
#include "Rational.h"


/*
Задача по решению автобусного билетика заключается в следующем:

	вам даётся n чисел, расставив между ними +-/*() нужно получить goal.
	Переставлять числа запрещается.

	Классически нужно из 6 чисел от 0 до 10 получить 100.
	Пример:  9 9 9 9 9 9 = 100  -> (9/9+9)*(9/9+9) = 100

Решать данную задачу будем используя обратную польскую нотацию.
	В ней вместо "a + b" пишется "a b +", то есть оператор идёт после двух операндов

Задача симметрична относительно знака goal,
	поэтому при попытке передать отрицательный знак
	вернется ошибка invalid_argument.

Аналогично при n = 1 вернется invalid_argument
*/

//объявления структур - см. описание ниже.
struct Ticket; //основная структура, с которой будем работать




/*
	* Чтобы не отслеживать унарный минус
	* для простоты используем список из 5 операторов
	* Напоминаем, что goal >= 0, поэтому использование унарного минуса для умножения не нужно.
	*/


typedef unsigned OPERATORS;
/*
static const OPERATORS
	PLUS = 0u,    //id: 0
	MINUS = 1u,
	MINUS_PLUS = 2u,  //конструкция вида: -(a) + b обозначаем ~
	MULTIPLE = 3u,
	DIVIDE = 4u; //id: 4
*/
//количество знаков в нашей реализации
#define OPERATORS_COUNT 5u




/*
	*Всего у нас должно быть (n-1) операторов.
	* У каждого оператора должен быть id который хранится в sign и позиция, которая хранится в pos.
	* Позиция - это номер числа, после которого этот оператор находится, например:
	* "a b с + ..." - позиция оператора "+" равна 2,
	*так как он стоит после третьего числа, а нумерация начинается с нуля
	*/

	//структура описывающая оператор
struct token {
	OPERATORS sign;
	unsigned pos;
};

//структура, описывающая конфигурацию операторов. Конфигурация операторов - массив токенов
struct OpersConfig {
	struct token* opers;
	unsigned opers_size;        //opers_size = size-1
};

/*инициализация позиций происходит в виде [ 1, 2, 3, 4, 5, 6...]
Параметр характеризует минимальное инициализируемое значение
(обычно это значение предыдущего элемента перед begin).
Это нужно чтобы гарантировать неубываемость последовательности
*/



//каждому строковому представлению мы даём свой id.
typedef unsigned str_id;



//строковое представление строим при помощи специальных токенов, где у каждой строки есть свой id
struct str_token {
	char *str;
	str_id id;
};


//структура билета
struct Ticket {
	//значение которое нужно получить
	Rational goal;
	//массив рациональных чисел между которыми нужно расставить знаки арифметических действий
	Rational* data;
	//заранее создаём массив в котором хранятся строковые представления чисел из data
	struct str_token* str_data;
	//data size
	unsigned size;
};



