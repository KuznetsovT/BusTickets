#pragma once



/*
Задача по решению автобусного билетика заключается в следующем:

	вам даётся n чисел, расставив между ними +-/*() нужно получить goal.
	Переставлять числа запрещается.

	Классически нужно из 6 чисел от 0 до 10 получить 100.
	Пример:  9 9 9 9 9 9 = 100  -> (9/9+9)*(9/9+9) = 100

Решать данную задачу будем используя обратную польскую нотацию.
	В ней вместо "a + b" пишется "a b +", то есть оператор идёт после двух операндов

Задача симметрична относительно знака goal,
	поэтому при попытке передать отрицательный знак
	вернется ошибка invalid_argument.

Аналогично при n = 1 вернется invalid_argument
*/





/*
	* Чтобы не отслеживать унарный минус
	* для простоты используем список из 5 операторов
	* Напоминаем, что goal >= 0, поэтому использование унарного минуса для умножения не нужно.
	*/

typedef unsigned OPERATORS;
static const OPERATORS
	PLUS = 0u,    //id: 0
	MINUS = 1u,
	MINUS_PLUS = 2u,  //конструкция вида: -(a) + b обозначаем ~
	MULTIPLE = 3u,
	DIVIDE = 4u;     //id: 4



/*
	*Всего у нас должно быть (n-1) операторов.
	* У каждого оператора должен быть id который хранится в sign и позиция, которая хранится в pos.
	* Позиция - это номер числа, после которого этот оператор находится, например:
	* "a b с + ..." - позиция оператора "+" равна 2,
	*так как он стоит после третьего числа, а нумерация начинается с нуля
	*/

	//структура описывающая оператор
struct token {
	OPERATORS sign;
	unsigned pos;
};




//каждому строковому представлению мы даём свой id.
typedef unsigned str_id;

//определяем какие id мы даём строковым выражениям
static const str_id
	NUM = 0u,    //число
	SUM = 1u,    //многочлен, сумма нескольких выражений
	MULT = 2u,   //произведение, последний знак - умножение
	DIV = 3u,    //частное, последний знак - деление
	EXPR = 4u;   //сложное выражение (используется в REVERSED_NOTATION)



//строковое представление строим при помощи специальных токенов, где у каждой строки есть свой id
struct str_token {
	char *str;
	unsigned size;
	str_id id;
};


//создаём тип операторов который далее будет вычислять сопостовлять каждому оператору его действие
typedef struct str_token(*binary_operator_str_token)(const struct str_token*, const struct str_token*);
